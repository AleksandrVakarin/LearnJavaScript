Объекты.

let user = {
	name: 'John',
	lastName: 'Doe',
	age: 30,
	'likes birds': true,
}

console.log(user.name)
console.log(user.age)
console.log(user)

user.isAdmin = true;

delete user.age;

Объект, объявленный через const, может быть изменён.
Дело в том, что объявление const защищает от изменений только саму переменную user, 
а не её содержимое.

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. 
Такой способ сработает с любым именем свойства:

user['likes birds'] = false;
console.log(user['likes birds']);

delete user['likes birds'];
console.log(user)

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. 
Например, имя свойства может храниться в переменной:

let key = 'user likes a dog';

user[key] = true;
console.log(user);
Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. 
После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.

let getName = prompt('What do you want to know?', 'name');
alert(user[getName]);

Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

let fruit = prompt('Which fruit need to by?', 'Apple');

let bag = {
	[fruit]: 5,
}
console.log(bag.Apple);

Квадратные скобки дают намного больше возможностей, чем запись через точку. 
Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

let bag = {
	[fruit + 'Orange']: 5,
}
console.log(bag.AppleOrange);

В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.

function createUser(name, age) {
	return {
		name: name,
		age: age,
	}
}
let newUser = createUser('Jack', 33)
console.log(newUser);

 return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };

Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д.
Но для свойств объекта такого ограничения нет. Иными словами, нет никаких ограничений к именам свойств. 

Есть небольшой подводный камень, связанный со специальным свойством __proto__. 
Мы не можем установить его в необъектное значение:

let obj = {};

obj.__proto__ = 5;
console.log(obj.__proto__);
присвоение примитивного значения 5 игнорируется.

Особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. 
Даже если свойства не существует – ошибки не будет!

console.log(user.noSuchProperty === undefined);
получаем true означает "свойства нет"

Также существует специальный оператор "in" для проверки существования свойства в объекте.
console.log('name' in user);
получаем true,  слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. 
Например:
let user = { age: 30 };

let key = "age";
alert( key in user ); получаем true, имя свойства было взято из переменной key

in нужно свойство существует, но содержит значение undefined

let obj = {
  test: undefined
};

alert( obj.test ); выведет undefined, значит свойство не существует?
alert( "test" in obj ); выведет true, свойство существует!
Подобные ситуации случаются очень редко, так как undefined обычно явно не присваивается. 
Для «неизвестных» или «пустых» свойств мы используем значение null.

Для перебора всех свойств объекта используется цикл for..in. 
Этот цикл отличается от изученного ранее цикла for(;;).

for (let key in user) {
	console.log(key);
	console.log(user[key]);
}
Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, как, 
например, let key здесь.

Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, 
остальные располагаются в порядке создания.
let codes = {
	"49": "Германия",
	"41": "Швейцария",
	"44": "Великобритания",
	"1": "США",
}

for (let code in codes) {
	console.log(code);
	console.log(codes[code]);
} получаем значения с 1 до 49 в порятке возрастания

let codes = {
	"+49": "Германия",
	"+41": "Швейцария",
	"+44": "Великобритания",
	"+1": "США",
}

for (let code in codes) {
	console.log(code);
	console.log(codes[code]);
} получаем значения с 49 до 1 в порятке создания


Проверка на пустоту:
 
let schedule = {};
function isEmpty(obj) {
  for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false;
  }
  return true;
}

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "get up";

alert( isEmpty(schedule) ); // false


