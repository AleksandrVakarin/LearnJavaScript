В качестве ключей для свойств объекта могут использоваться только строки или символы

«Символ» представляет собой уникальный идентификатор.

Создаются новые символы с помощью функции Symbol():
let id = Symbol();

Символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
let id = Symbol('id');

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

Символы не преобразуются автоматически в строки!
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

Если нужно вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString()
alert(id.toString()); // Symbol(id)

Или обратиться к свойству symbol.description, чтобы вывести только описание:
alert(id.description); // id

«Скрытые» свойства
Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.

Используем для этого символьный ключ:
let user = {
	name: 'Viktor'
}

let id_3 = Symbol('id')

user[id_3] = 1;

console.log(user[id_3]) // 1

Лучше использовать Symbol("id"), а не строку "id", если объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.

Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект user. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.

Сторонний код может создать для этого свой символ Symbol("id")

Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
let id_4 = Symbol('id');

let userTwo = {
	name: 'Rik',
	[id_4]: 4,
}

console.log(userTwo);

Символы игнорируются циклом for…in
Свойства, чьи ключи – символы, не перебираются циклом for..in.
let id = Symbol("id");
let user = {
  name: "Вася",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );

Object.keys(user) также игнорирует символы.

А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
let clone = Object.assign({}, userTwo);
console.log(clone[id_4])

Идея заключается в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, id в примере выше).

Глобальные символы.
Иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.

Существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).
Проверяет глобальный реестр, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.

// читаем символ из глобального реестра и записываем его в переменную:

let id_5 = Symbol.for('id');
// читаем его снова и записываем в другую переменную (возможно, из другого места кода):
let id_5Again = Symbol.for('id');
// проверяем -- это один и тот же символ:
console.log(id_5 == id_5Again);// true

Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

Symbol.keyFor
Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.

let symbol_1 = Symbol.for('name');
let symbol_2 = Symbol.for('id');

console.log(Symbol.keyFor(symbol_1)); // name
console.log(Symbol.keyFor(symbol_2)); // id

Не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.

let globaSymbol = Symbol.for('lastName');
let localSymbol = Symbol('age');

console.log(Symbol.keyFor(globaSymbol)); // lastName, глобальный символ

console.log(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

console.log(localSymbol.description); // age

Системные символы
Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.
Well-known symbols:
https://tc39.github.io/ecma262/#sec-well-known-symbols

Итог:
Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

«Скрытые» свойства объектов.

Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.