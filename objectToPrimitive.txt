Преобразование объектов в примитивы

Это важное ограничение: результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!

Исключения, когда такие операции возможны и вполне уместны. Например, вычитание или сравнение дат (Date объекты). Мы встретимся с ними позже.

Правила преобразования

1.Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
2.Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
3.Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы.

Хинты
Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации.

"string"
Преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;

"number"
Преобразования объекта к числу, в случае математических операций:
/ явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

"default"
Бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.

Если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".

// бинарный плюс использует хинт "default"
let total = obj1 + obj2;

// obj == number использует хинт "default"
if (user == 1) { ... };

Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".

Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:

1.Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
2.Иначе, если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
3.Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

Symbol.toPrimitive
Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.

Например, здесь объект user реализует его:
let user = {
	name: 'Lack',
	money: 1000,

	[Symbol.toPrimitive](hint) {
		alert(`hint: ${hint}`);
		return hint == 'string' ? `{name: ${this.name}}` : this.money;
	}
}

alert(user); // hint: string -> {name: "Lack"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
Как мы можем видеть из кода, user становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. Единый метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования.

toString/valueOf
Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:

Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).
Для других хинтов: вызвать метод valueOf, а если он не существует или возвращает объект вместо примитивного значения, то toString (таким образом, valueOf имеет приоритет для математических операций).
Метод toString возвращает строку "[object Object]".
Метод valueOf возвращает сам объект.
Если toString или valueOf возвращает объект, то он игнорируется (так же, как если бы метода не было).
let userTwo = {name: 'Jhon'}

alert(user.valueOf() === user); // true
Значение по умолчанию valueOf упоминается здесь только для полноты картины, чтобы избежать какой-либо путаницы.

Применим эти методы для настройки преобразования:
let userThree = {
	name: 'Tack',
	money: 2000,

	toString() {
		return `{name: '${this.name}'}`;
	},

	valueOf() {
		return this.money
	}
}

alert(userThree); // toString -> {name: "Tack"}
alert(+userThree); // valueOf -> 2000
alert(userThree + 1700); // valueOf -> 1700
Получилось то же поведение, что и в предыдущем примере с Symbol.toPrimitive.

Часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. В этом случае мы можем реализовать только toString:
let userFour = {
	name: 'Colen',

	toString() {
		return this.name;
	}
}

alert(userFour); // Colen
alert(userFour + 500); // Colen500
Преобразование может вернуть любой примитивный тип
Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.

Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возвращал именно число для хинта "number".

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.

Многие операторы и функции выполняют преобразования типов, например, умножение * преобразует операнды в числа.

Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:

Объект преобразуется в примитив (с использованием правил, описанных выше).
Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.

let obj = {
	toString() {
		return '2';
	}
}

alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом
alert(obj + 2); // 22 ("2" + 2), преобразование к примитиву вернуло строку => конкатенация

Итог:
Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Существует всего 3 типа (хинта) для этого:

"string" (для alert и других операций, которым нужна строка)
"number" (для математических операций)
"default" (для некоторых других операторов, обычно объекты реализуют его как "number")
Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

Алгоритм преобразования таков:

Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
В случае, если хинт равен "string"
происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
В случае, если хинт равен "number" или "default"
происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
Все эти методы должны возвращать примитив (если определены).

На практике часто бывает достаточно реализовать только obj.toString() в качестве универсального метода для преобразований к строке, который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.