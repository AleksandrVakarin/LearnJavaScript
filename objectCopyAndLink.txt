Копирование объектов и ссылки.

Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», 
тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

Когда мы выполняем действия с объектом, к примеру, берём свойство user.name, движок JavaScript просматривает то, что 
находится по этому адресу, и выполняет операцию с самим объектом.


При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
let user = { name: "John" };
let admin = user; // копируется ссылка
Пример:
let user = {
	name: 'Jhon',
}

let Admin = user;
Admin.name = 'Greg';

console.log(user);// Greg

Два объекта равны только в том случае, если это один и тот же объект.
console.log(user === Admin)// true

Два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):
let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false

Клонирование и объединение, Object.assign

let clone = {};

for (let key in user) {
	clone[key] = user[key]
}

clone.name = 'Ashley';

console.log(user)// Greg
console.log(clone)// Ashley

Также мы можем использовать для этого метод Object.assign.

let permissionOne = {
	canView: true,
}

let permissionTwo = {
	canEdit: true,
}

Object.assign(user, permissionOne, permissionTwo);
console.log(user); // user = { name: "Greg", canView: true, canEdit: true }

Если скопированное имя свойства уже существует, оно будет перезаписано:
Object.assign(user, {name: 'Roy'});
console.log(user);

Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:
let newClone = Object.assign({}, user);
console.log(newClone)//newClone = {name: 'Roy', canView: true, canEdit: true}

Вложенное клонирование.
newClone.size = {
    height: 182,
    width: 50
}

console.log(newClone){name: 'Roy', canView: true, canEdit: true, size: {…}}
теперь недостаточно просто скопировать, потому что newClone.sizes – это объект, 
он будет скопирован по ссылке. Таким образом, объекты будут иметь общий объект sizes:
изменяея свойства в первом объекте будет виден результат в другом

«глубокое клонирование»

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не 
изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.

Также мы можем использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта. 
К сожалению он поддерживается только современными браузерами. Здесь можно ознакомиться с поддержкой этого метода.









