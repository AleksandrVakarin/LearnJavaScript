Методы объектов "this"

let user = {
	name: 'Jhon',
	age: 30,
}

user.sayHi = function() {
	alert('Hello')
}

user.sayHi();// Hello
console.log(user);

Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию приветствия, и присвоили её свойству user.sayHi нашего объекта.

Затем мы можем вызвать ee как user.sayHi(). Теперь пользователь может говорить!

Функцию, которая является свойством объекта, называют методом этого объекта.

Можно таким способом:

function sayBy() {
	alert('Goodby')
}

user.sayBy = sayBy;
user.sayBy();// Goodby

Сокращённая запись метода
Существует более короткий синтаксис для методов в литерале объекта:

user = {
	sayTry() {
		alert('Try')
	}
}
user.sayTry();// Try


Ключевое слово «this» в методах
Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.

Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в объекте user.

Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который используется для вызова метода.

user = {
	name: 'Jack',
	sayTry() {
		alert('Try')
		alert(this.name)
	}
}
user.sayTry();// Try // Jack

Здесь во время выполнения кода user.sayTry() значением this будет являться user (ссылка на объект user).

Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

let newUser = {
	name: 'Klark',
	age: 30,
	sayName() {
		alert(newUser.name)
	}
}

newUser.sayName()

…Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

«this» не является фиксированным
В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.

Значение this вычисляется во время выполнения кода, в зависимости от контекста.

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:

let myUser = { name: 'Sara'};
let admin = {name: 'Roy'}

function sayThisName() {
	alert(this.name);
}
используем одну и ту же функцию в двух объектах:
myUser.f = sayThisName;
admin.f = sayThisName;

myUser.f();// Sara
admin.f();// Roy
или так:
myUser['f']();// Sara
admin['f']();// Roy

Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj. Так что, в приведённом выше примере это либо user, либо admin.

У стрелочных функций нет «this»
Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

Например, здесь arrow() использует значение this из внешнего метода userOne.LastName():

let userOne = {
	lastName: 'Gray',
	sayLastName() {
		let arrow = () => alert(this.lastName);// Стрелочная функция
		arrow();
	} 
}
userOne.sayLastName();

Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное this, а скорее хотим взять его из внешнего контекста. Позже в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.

Итог:
Функции, которые находятся в свойствах объекта, называются «методами».
Методы позволяют объектам «действовать»: object.doSomething().
Методы могут ссылаться на объект через this.
Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
Функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

function tryThis() {
	return {
		name: 'Collen',
		ref() {
			return this
		}
	}
}

let userTryThis = tryThis();
alert(userTryThis.ref().name);// Collen


let calculator = {
	read() {
		this.a = +prompt('Insert a', 0);
		this.b = +prompt('Insert b', 0);
	},
	sum() {
		return this.a + this.b
	},
	mul() {
		return this.a * this.b
	},

}

calculator.read();
alert(calculator.sum());
alert(calculator.mul());


let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep: function() { // показывает текущую ступеньку
    alert( this.step );
    return this;
  }
};

ladder
	.up()
	.up()
	.down()
	.showStep()
	.down()
	.showStep(); // показывает 1 затем 0