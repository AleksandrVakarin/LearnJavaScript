Конструктор, оператор "new"
Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.

Это можно сделать при помощи функции-конструктора и оператора "new".

Функция-конструктор
Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
1.Имя функции-конструктора должно начинаться с большой буквы.
2.Функция-конструктор должна выполняться только с помощью оператора "new".


function User(name) {
	this.name = name;
	this.isAdmin = false;
}

let user = new User('Jack');

console.log(user.name);
console.log(user.isAdmin);

Когда функция вызывается как new User(...), происходит следующее:

Создаётся новый пустой объект, и он присваивается this.
Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
Возвращается значение this.
Другими словами, new User(...) делает что-то вроде:

function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}

Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), new User("Alice") и так далее. Данная конструкция гораздо удобнее и читабельнее, чем многократное создание литерала объекта.
Основная цель конструкторов – реализовать код для многократного создания однотипных объектов.

new function() { … }
Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:

// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.

let userOne = new function() {
	this.name = 'Grag';
	this.age = 30;
	this.isAdmin = true;
}

console.log(userOne)


Возврат значения из конструктора, return
Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.

Но если return всё же есть, то применяется простое правило:

При вызове return с объектом, вместо this вернётся объект.
При вызове return с примитивным значением, оно проигнорируется.
Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

function UserTwo() {
	this.name = 'Roy';
	return {
		name: 'Sally'
	}
}

console.log( new UserTwo().name ) // Sally

Можем не ставить круглые скобки после new(плохая практика):
let user = new User; // <-- без скобок
// то же, что и
let user = new User();

Создание методов в конструкторе
Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.

Конечно, мы можем добавить к this не только свойства, но и методы.

Например, new UserThree(name) ниже создаёт объект с заданным name и методом sayName:

function UserThree(name) {
	this.name = name;

	this.sayName = function() {
		alert('my name ' + this.name)
	}
}

let john = new UserThree('John');
john.sayName(); // my name John

Итог:
Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.
Функции-конструкторы следует вызывать только с помощью new. Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.
Мы можем использовать конструкторы для создания множества похожих объектов.


function A() {
	this.name = name;
}
function B() {
	this.name = name;
}

let a = new A('a');
let b = new B('a');

alert( a == b ); // false

let obj = {};

function C() {
	return obj
}

function D() {
	return obj
}

alert( new C() == new D());// true

function Calculator() {
	this.read = function() {
		this.a = +prompt('Insert a', 0);
		this.b = +prompt('Insert b', 0);
	}
	this.sum = function() {
		return this.a + this.b;
	}
	this.mul = function() {
		return this.a * this.b;
	}

}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum());
alert( "Mul=" + calculator.mul());



function Accumulator(startingValue) {
	this.value = startingValue;
	this.read = function() {
		this.value += +prompt('Insert number', 0)
	}
}

let accumulator = new Accumulator(1); // начальное значение 1

accumulator.read(); // прибавляет введённое пользователем значение к текущему значению
accumulator.read(); // прибавляет введённое пользователем значение к текущему значению

alert(accumulator.value); // выведет сумму этих значений